import itertools
import time
from typing import Tuple
from scipy import ndimage
import numpy as np
import cv2
from scipy.ndimage import binary_closing

RESIZE_RATIO = 2


# crop redundant empty lines of image
def __crop_mask(mask: np.ndarray):
    up, down = 0, len(mask)
    left, right = 0, len(mask[0])

    for i, line in enumerate(mask):
        if (line == [False for _ in range(len(line))]).all():
            up = i
        else:
            break
    for j in range(len(mask)):
        if (mask[-j] == [False for _ in range(len(line))]).all():
            down = len(mask) - j
        else:
            break

    transposed_mask = np.transpose(mask)
    for i, line in enumerate(transposed_mask):
        if (line == [False for _ in range(len(line))]).all():
            left = i
        else:
            break
    for j in range(len(transposed_mask)):
        if (transposed_mask[-j] == [False for _ in range(len(line))]).all():
            right = len(transposed_mask) - j
        else:
            break

    return mask[up:down, left: right]


# rescale mask to reduce enumeration
def __rescale_mask(mask: np.ndarray, ratio=RESIZE_RATIO):
    new_mask = np.zeros(shape=(np.array(mask.shape) / ratio).astype(int), dtype=bool)
    x = 0
    for i, line in enumerate(mask):
        if i % ratio != 0:
            continue
        y = 0
        for j, elem in enumerate(line):
            if j % ratio != 0:
                continue
            if x < new_mask.shape[0] and y < new_mask.shape[1]:
                new_mask[x][y] = elem
            y += 1
        x += 1
    return new_mask


# extend object mask to fit polygon mask
def __extend_object(obj: np.ndarray, shape: Tuple, x: int, y: int):
    new_object = np.zeros(shape=shape)
    for i, line in zip(range(y, len(obj) + y), obj):
        tmp_line = np.concatenate((np.zeros(x), line.copy()))
        tmp_line = np.concatenate((tmp_line, np.zeros(shape[1] - len(tmp_line))))
        new_object[i] = tmp_line
    return new_object.astype(dtype=bool)


# placing objects
def solve(objects: list, polygon: np.ndarray, index=None) -> np.ndarray:
    print('--- Starting timer ---')
    start_time = time.time()
    if index is not None:
        print('image', index)
    indexes = [i for i in range(len(objects))]
    possible_cases = itertools.permutations(indexes)
    max_square = np.sum(polygon.astype(int))
    intersection = max_square
    max_intersection = polygon
    max_placed_objects = len(objects)
    for case in possible_cases:
        print('\tcase', case, ":")
        objects_placed = 0
        new_polygon = polygon.copy()
        new_polygon = __rescale_mask(new_polygon)
        for i in case:
            intersects = False
            new_obj = __rescale_mask(objects[i])
            for angle in range(0, 360, 15):
                transformed_object = ndimage.rotate(new_obj, angle, order=1)
                transformed_object = binary_closing(transformed_object)  # fill some points generated by rotation
                transformed_object = __crop_mask(transformed_object)
                for x in range(len(new_polygon[0])):
                    if x > len(new_polygon[0]) - len(transformed_object[0]):
                        break
                    for y in range(len(new_polygon)):
                        if y > len(new_polygon) - len(transformed_object):
                            break
                        extended_object = __extend_object(transformed_object, new_polygon.shape, x, y)
                        intersection = np.logical_and(extended_object, new_polygon)
                        if (extended_object == intersection).all():
                            objects_placed += 1
                            print('\t\tcheck')
                            new_polygon = np.logical_xor(extended_object, new_polygon)
                            intersects = True
                            break
                    if intersects:
                        break
                if intersects:
                    break
            if objects_placed == max_placed_objects:
                print("--- %s seconds ---" % (time.time() - start_time))
                return new_polygon
            tmp_square = np.sum(new_polygon.astype(int))
            if tmp_square <= max_square:
                max_square = tmp_square
                max_intersection = new_polygon
    print("--- %s seconds ---" % (time.time() - start_time))
    return max_intersection


# Quality control value
def coverage_ratio(intersection: np.ndarray, objects: list, polygon: np.ndarray) -> float:
    rescaled_objects_sqr = 0
    for obj in objects:
        rescaled_objects_sqr += np.sum(__rescale_mask(obj).astype(int))
    polygon_sqr = np.sum(__rescale_mask(polygon).astype(int))
    intersection_sqr = np.sum(intersection.astype(int))
    return (polygon_sqr - intersection_sqr) / rescaled_objects_sqr
